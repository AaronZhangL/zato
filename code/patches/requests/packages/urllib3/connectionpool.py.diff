--- connectionpool.py.orig	2017-04-17 18:28:40.733780608 +0200
+++ connectionpool.py	2017-04-17 18:31:43.297783888 +0200
@@ -240,11 +240,15 @@
         # If this is a persistent connection, check if it got disconnected
         if conn and is_connection_dropped(conn):
             log.debug("Resetting dropped connection: %s", self.host)
-            conn.close()
-            if getattr(conn, 'auto_open', 1) == 0:
-                # This is a proxied connection that has been mutated by
-                # httplib._tunnel() and cannot be reused (since it would
-                # attempt to bypass the proxy)
+            try:
+                conn.close()
+                if getattr(conn, 'auto_open', 1) == 0:
+                    # This is a proxied connection that has been mutated by
+                    # httplib._tunnel() and cannot be reused (since it would
+                    # attempt to bypass the proxy)
+                    conn = None
+            except Exception, e:
+                log.info("Closing connection failed: %s, force new connection" % str(e))
                 conn = None
 
         return conn or self._new_conn()
@@ -312,12 +316,6 @@
         if hasattr(err, 'errno') and err.errno in _blocking_errnos:
             raise ReadTimeoutError(self, url, "Read timed out. (read timeout=%s)" % timeout_value)
 
-        # Catch possible read timeouts thrown as SSL errors. If not the
-        # case, rethrow the original. We need to do this because of:
-        # http://bugs.python.org/issue10272
-        if 'timed out' in str(err) or 'did not complete (read)' in str(err):  # Python 2.6
-            raise ReadTimeoutError(self, url, "Read timed out. (read timeout=%s)" % timeout_value)
-
     def _make_request(self, conn, method, url, timeout=_Default, chunked=False,
                       **httplib_request_kw):
         """
